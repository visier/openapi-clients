# This contains logic to post-process the API reference generated by redocly prior to pushing to our documentation team
import re

# Define the path to the input and output HTML files; for convenience, these are the same, but you can make them
# different if you want to verify that things have changed as a result of this
input_file_path = './output/api-reference.htm'
output_file_path = input_file_path


def strip_html_comments(html_input: str) -> str:
    """ Removes HTML comments we do not care for generated by redocly """

    # Define a regex pattern to remove the specific HTML comment
    # This pattern looks for <!-- --> followed by optional whitespace
    pattern = r"<!-- -->\s*"

    # Substitute the pattern in the HTML content with an empty string
    return re.sub(pattern, '', html_input)


def strip_version(html_input: str) -> str:
    """ Removes the version information from generated output """

    # Define a regex pattern to remove the version, which is present in two places:
    #  * In the HTML inside a span tag
    #  * In the API Specification JSON
    pattern = r'(<span>\(|,"version":")[0-9\.]+(\)</span>|")'

    # Substitute the pattern in the HTML content with an empty string
    return re.sub(pattern, '', html_input)


def correct_br_tags(html_input: str) -> str:
    """ Replaces <br> with XML-compliant <br/> """
    return html_input.replace("<br>", "<br/>")


def script_tag_adjustments(html_input: str) -> str:
    """
    redocly does not wrap <script> tags in CDATA, so this ends up being considered invalid XML
    Wrap them in <![CDATA[ ... ]]> and encode these in JavaScript comments so these validate cleanly and are still usable
    https://www.w3.org/TR/xhtml1/#h-4.8
    """
    pattern = re.compile('<script>(.*?)</script>', re.DOTALL)

    def add_cdata(m: re.Match) -> str:
        if m.group(1).strip():
            return f"{m.string[m.start(0):m.start(1)]}\n" \
                   f"//<![CDATA[" \
                   f"{m.string[m.start(1):m.end(1)]}" \
                   f"//]]>\n" \
                   f"{m.string[m.end(1):m.end(0)]}"
        else:
            return m.group(0)

    return pattern.sub(add_cdata, html_input)


if __name__ == '__main__':

    # Read the HTML content from the input file
    with open(input_file_path, 'r', encoding='utf-8') as file:
        content = file.read()

    content = strip_html_comments(content)
    content = strip_version(content)
    content = correct_br_tags(content)
    content = script_tag_adjustments(content)

    # Write the cleaned HTML content to the output file
    with open(output_file_path, 'w', encoding='utf-8') as file:
        file.write(content)
